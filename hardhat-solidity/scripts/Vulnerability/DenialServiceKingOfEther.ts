import { ethers } from "hardhat";
import assert from 'assert'
import { sleep } from "../../src/helper";
import assert from "assert";
import {factoryAddress} from "../../src/utils";
// npx hardhat run scripts/Vulnerability/DenialServiceKingOfEther.ts
async function attack_ok() {
    const [alice, bob, charlie, david] = await ethers.getSigners();

    const ethValue = ethers.utils.parseEther("1");

    const KingOfEtherFatctory = await ethers.getContractFactory("KingOfEther");
    const KingOfEther = await KingOfEtherFatctory.deploy();

    await KingOfEther.deployed();

    console.log(`send with 1 ETH and  deployed to ${KingOfEther.address}`);

    await KingOfEther.connect(bob).claimThrone({value:ethers.utils.parseEther("1")})
    await sleep(2000);
    await KingOfEther.connect(charlie).claimThrone({value:ethers.utils.parseEther("2")})
    await sleep(2000);


    const KingOfEtherAttackFatctory = await ethers.getContractFactory("KingOfEtherAttack");
    const KingOfEtherAttack = await KingOfEtherAttackFatctory.deploy(KingOfEther.address);
    await KingOfEtherAttack.deployed();

    await KingOfEtherAttack.attack({value:ethers.utils.parseEther("3")})
    await sleep(2000);
    await KingOfEther.connect(alice).claimThrone({value:ethers.utils.parseEther("4")})



}

async function proper_work_ok() {
    const [alice, bob, charlie, david] = await ethers.getSigners();
    console.log("alice:", alice.address)
    console.log("bob:", bob.address)
    console.log("charlie:", charlie.address)
    console.log("david:", david.address)

    const ethValue = ethers.utils.parseEther("1");

    const KingOfEtherFatctory = await ethers.getContractFactory("KingOfEtherProper");
    const KingOfEther = await KingOfEtherFatctory.deploy();

    await KingOfEther.deployed();

    console.log(`send with 1 ETH and  deployed to ${KingOfEther.address}`);

    await KingOfEther.connect(bob).claimThrone({value:ethers.utils.parseEther("1")})
    await sleep(2000);
    await KingOfEther.connect(charlie).claimThrone({value:ethers.utils.parseEther("2")})
    await sleep(2000);

    const KingOfEther_balance = await KingOfEther.balance()
    console.log("KingOfEther_balance:", ethers.utils.formatEther(KingOfEther_balance))

    const bob_b = await KingOfEther.balances(bob.address)
    console.log("bob_balance locked in :", ethers.utils.formatEther(bob_b))

    const charlie_king = await KingOfEther.king()
    console.log("current king is :", charlie_king)
    assert.strictEqual(charlie.address, charlie_king)

    const KingOfEtherAttackFatctory = await ethers.getContractFactory("KingOfEtherAttack2");
    const KingOfEtherAttack = await KingOfEtherAttackFatctory.deploy(KingOfEther.address);
    await KingOfEtherAttack.deployed();
    let KingOfEtherAttack_balance = await ethers.provider.getBalance(KingOfEtherAttack.address);
    console.log("KingOfEtherAttack_balance before attack:", ethers.utils.formatEther(KingOfEtherAttack_balance))

    await KingOfEtherAttack.attack({value:ethers.utils.parseEther("3")})
    await sleep(2000);

    // 换 king 之后 才能查出之前的账号的余额
    const charlie_b = await KingOfEther.balances(charlie.address)
    console.log("charlie_balance locked in :", ethers.utils.formatEther(charlie_b))

    // 当前king的账号是0
    //const b = await KingOfEther.balances(KingOfEtherAttack.address)
    //console.log("KingOfEtherAttack_balance locked in :", ethers.utils.formatEther(b))

    await KingOfEther.connect(alice).claimThrone({value:ethers.utils.parseEther("4")})

    // 再查king的账号
    const b = await KingOfEther.balances(KingOfEtherAttack.address)
    console.log("KingOfEtherAttack_balance locked in :", ethers.utils.formatEther(b))
    assert.strictEqual(b.toString(), ethers.utils.parseEther("3").toString())

    const alice_king = await KingOfEther.king()
    console.log("current king is :", alice_king)
    assert.strictEqual(alice_king, alice.address, "current king should ok, it's "+alice.address)

    // 这里如果不打开这个fallback函数，依然是无法接收withdraw() 转账的，但不影响 King 往后继续替换，也就不会出现拒绝服务攻击
    await KingOfEtherAttack.withdraw()

    KingOfEtherAttack_balance = await ethers.provider.getBalance(KingOfEtherAttack.address);
    console.log("KingOfEtherAttack_balance after withdraw:", ethers.utils.formatEther(KingOfEtherAttack_balance))
}


async function main() {
    //await attack_ok();
    await proper_work_ok();
}



// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
