import { ethers } from "hardhat";

// npx hardhat run scripts/Vulnerability/FailedRandom.ts
async function attack() {

    const ethValue = ethers.utils.parseEther("1");

    const InsecureAirdropFatctory = await ethers.getContractFactory("InsecureAirdrop");
    const InsecureAirdrop = await InsecureAirdropFatctory.deploy([10]);
    await InsecureAirdrop.deployed();
    console.log(`deployed InsecureAirdrop to ${InsecureAirdrop.address}`);

    const AttackFatctory = await ethers.getContractFactory("Attack");
    const Attack = await AttackFatctory.deploy(InsecureAirdrop.address);
    await Attack.deployed();
    console.log(`deployed Attack to ${Attack.address}`);

    await Attack.attack(5)
    console.log("balacne:",await Attack.getBalance());  // 会得到总共 10*5 次 = 50余额
}

async function attack_failed() {

    const ethValue = ethers.utils.parseEther("1");

    const InsecureAirdropFatctory = await ethers.getContractFactory("FixedAirdrop");
    const InsecureAirdrop = await InsecureAirdropFatctory.deploy([10]);
    await InsecureAirdrop.deployed();
    console.log(`deployed InsecureAirdrop to ${InsecureAirdrop.address}`);

    const AttackFatctory = await ethers.getContractFactory("Attack");
    const Attack = await AttackFatctory.deploy(InsecureAirdrop.address);
    await Attack.deployed();
    console.log(`deployed Attack to ${Attack.address}`);

    await Attack.attack(5)
    console.log("balacne:",await Attack.getBalance());  // 会得到总共 10*5 次 = 50余额
}


async function main() {
    //await attack();
    await attack_failed();
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
