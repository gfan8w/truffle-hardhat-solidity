import { ethers } from "hardhat";

// npx hardhat run scripts/Vulnerability/FailedRandom.ts
async function main() {

    const ethValue = ethers.utils.parseEther("1");

    const GuessTheRandomNumberFatctory = await ethers.getContractFactory("GuessTheRandomNumber");
    const GuessTheRandomNumber = await GuessTheRandomNumberFatctory.deploy({ value: ethValue });

    await GuessTheRandomNumber.deployed();

    console.log(`send with 1 ETH and  deployed to ${GuessTheRandomNumber.address}`);


    const GuessTheRandomNumberAttackFatctory = await ethers.getContractFactory("GuessTheRandomNumberAttack");
    const GuessTheRandomNumberAttack = await GuessTheRandomNumberAttackFatctory.deploy();
    await GuessTheRandomNumberAttack.deployed();

    const attackee_balance = await ethers.provider.getBalance(GuessTheRandomNumber.address);
    const first_balance = await GuessTheRandomNumberAttack.getBalance()
    const first_balance2 = await ethers.provider.getBalance(GuessTheRandomNumberAttack.address);
    console.log("attackee_balance:", ethers.utils.formatEther(attackee_balance))
    console.log("first_balance:", first_balance.toString(), " , ", first_balance2.toString())
    await GuessTheRandomNumberAttack.attack(GuessTheRandomNumber.address);
    const attackee_balance2 = await ethers.provider.getBalance(GuessTheRandomNumber.address);
    console.log("attackee_balance:", ethers.utils.formatEther(attackee_balance2))
    console.log("second_balance:", (ethers.utils.formatEther(await GuessTheRandomNumberAttack.getBalance())), ", ", ethers.utils.formatEther((await ethers.provider.getBalance(GuessTheRandomNumberAttack.address))))



}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
