import { ethers } from "hardhat";

// npx hardhat run scripts/Vulnerability/ExtcodesizeByPass.ts
async function attack_ok() {
    const [alice, bob, charlie, david] = await ethers.getSigners();

    const ethValue = ethers.utils.parseEther("1");

    const ExitCodeSizeTargetFatctory = await ethers.getContractFactory("ExitCodeSizeTarget");
    const ExitCodeSizeTarget = await ExitCodeSizeTargetFatctory.deploy();
    await ExitCodeSizeTarget.deployed();
    console.log(`deployed to ${ExitCodeSizeTarget.address}`);

    const ExitCodeSizeFailedAttackFatctory = await ethers.getContractFactory("ExitCodeSizeFailedAttack");
    const ExitCodeSizeFailedAttack = await ExitCodeSizeFailedAttackFatctory.deploy();
    await ExitCodeSizeFailedAttack.deployed();
    console.log(`deployed to ${ExitCodeSizeFailedAttack.address}`);

    try {
        await ExitCodeSizeFailedAttack.pwn(ExitCodeSizeTarget.address);
    }catch (e){
        console.error(e)
    }

    console.log("status: ", await ExitCodeSizeTarget.pwned());

    const ExitCodeSizeHackSuccessFatctory = await ethers.getContractFactory("ExitCodeSizeHackSuccess");
    const ExitCodeSizeHackSuccess = await ExitCodeSizeHackSuccessFatctory.deploy(ExitCodeSizeTarget.address);
    await ExitCodeSizeHackSuccess.deployed();
    console.log(`deployed to ${ExitCodeSizeHackSuccess.address}`);

    console.log("status: ", await ExitCodeSizeTarget.pwned());
    console.log("isContract: ", await ExitCodeSizeHackSuccess.isContract());


}


async function main() {
    await attack_ok();
}



// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
