pragma solidity ^0.8.13;

contract KingOfEther {
    address public king;
    uint public balance;

    function claimThrone() external payable {
        require(msg.value > balance, "Need to pay more to become the king");

         (bool sent, ) = king.call{value: balance}("");
         require(sent, "Failed to send Ether");
        // payable(king).transfer(balance);


        balance = msg.value;
        king = msg.sender;
    }
}

// 1. Alice 部署 KingOfEther 合约。
//2. Alice 调用 KingOfEther.claimThrone() 发送 1 个以太到 KingOfEther 合约中成为“以太之王”。
//3. Bob 调用 KingOfEther.claimThrone() 发送 2 个以太到 KingOfEther 合约中成为新王。
//4. Alice 收到 1 个以太币的退款。
//5. Eve 使用 KingOfEther 的地址部署攻击合约 KingOfEtherAttack。
//6. KingOfEtherAttack 调用 attack() 向 KingOfEther 合约中发送 3 个以太。
//7. KingOfEtherAttack 合约成为新王。
//8. Bob，再次调用 KingOfEther.claimThrone() 向 KingOfEther 合约中发送了 20 个以太。
//9. Bob 发现自己的交易一直被 revert，无法成为新王。至此，Eve 的攻击使 KingOfEtherAttack 合约永久失效，KingOfEtherAttack 合约成为了永远的“以太之王”。

// VM Exception while processing transaction: reverted with reason string 'Failed to send Ether'
contract KingOfEtherAttack {
    KingOfEther kingOfEther;

    // 因为缺少fallback，该合约无法接收eth，导致call的转账失败
    // fallback () external payable {}

    constructor(KingOfEther _kingOfEther) {
        kingOfEther = KingOfEther(_kingOfEther);
    }

    function attack() public payable {
        kingOfEther.claimThrone{value: msg.value}();   // 这里直接透传了 msg.value, Attack合约本身就不需要余额？
    }
}


// 修正方法： 2步法，异步法，取回 eth，用另外一个方法。不要在claimThrone里一步完成。让用户自己取回而不是直接发送给他

contract KingOfEtherProper {
    address public king;
    uint public balance;  // 这里为什么要依赖一个内部变量，而不是 address(this).balance？ 因为 address(this).balance 有不可靠的地方。
    mapping(address => uint256) public balances;

    function claimThrone() external payable {
        require(msg.value > balance, "Need to pay more to become the king");

        // 使用对象，将每次的放进来的balance存起来。
        balances[king] += balance;

        balance = msg.value;
        king = msg.sender;

    }

    function withdraw() public {
        require(msg.sender != king, "current king can't withdraw");
        uint256 amount = balances[msg.sender];
        balances[msg.sender] =0;

        // 建议用 transfer代替 call。call 会消耗完所有gas。
        payable(msg.sender).transfer(balance);

    }


}


contract KingOfEtherAttack2 {
    KingOfEtherProper kingOfEther;

    // 这里如果不打开这个fallback函数，依然是无法接收withdraw() 转账的，但不影响 King 往后继续替换，也就不会出现拒绝服务攻击
     fallback () external payable {}

    constructor(KingOfEtherProper _kingOfEther) {
        kingOfEther = KingOfEtherProper(_kingOfEther);
    }

    function attack() public payable {
        kingOfEther.claimThrone{value: msg.value}();
    }

    // 使用异步法解决后，加上withdraw函数来取回
    function withdraw() public {
        kingOfEther.withdraw();
    }

}

// 修复建议
//
//作为开发者
//
//1. 在智能合约开发中应当注意处理连续失败的情况，例如将可能出现失败的外部调用逻辑异步处理。
//
//2. 在使用 call 进行外部调用以及使用循环和遍历时应当注意 Gas 消耗。
//
//3. 避免对单个角色过度授权的情况，处理合约权限时应做到合理的权限划分，对拥有权限的角色使用多签钱包管理，防止由于私钥泄漏导致权限丢失。

// 作为审计者
//
//内部合约进行分析：
//
//1. 注意合约中是否存在逻辑上的错误导致影响了可用性。
//
//2. 注意是否存在由于虚拟机调用深度过大导致的 DoS（深度最大 1024）。
//
//3. 重点关注在代码逻辑中是否存在大量消耗 Gas 的逻辑。
//
//
//
//外部合约进行分析：
//
//1. 关注与外部合约进行交互的时候没有考虑好兼容性的问题，如：未处理 TRC20-USDT 的返回值的兼容性，导致代币被锁定。
//
//2. 重点检查有没有判断外部合约调用的返回值是否符合预期的效果。
//
//
//
//对权限管理进行分析：
//
//在审计中需要检查和确认所有函数方法的可见性及调用权限，需要结合项目方提供设计文档在审计中根据设计文档中的描述一一确认权限。如果发现过度授权或权限划分不清晰的需要与项目方交流改进方法，并且与项目方沟通运营操作的流程，确保流程上能够避免合约在运营的时候管理员操作失误或配置错误的情况。


// 参考： https://mp.weixin.qq.com/s/SPc96mQs3VO_OdDLKL1Vow









